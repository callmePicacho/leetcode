## 1. 归并排序

基本思想：分而治之，每次将数组对半分，借助额外空间，合并两个有序数组，得到一个更大的有序数组，是稳定性的算法

将数组升序排列：

```go
func sortArray(arr []int) []int {
    mergeSort(arr, 0, len(arr)-1)
    return arr
}

func mergeSort(arr []int, left, rightEnd int) {
    if left < rightEnd {
        mid := left + (rightEnd-left) >> 1
        mergeSort(arr, left, mid)
        mergeSort(arr, mid+1, rightEnd)
        // merge [left,mid] [mid+1,rightEnd]
        merge(arr, left, mid, mid+1, rightEnd)
    }
}

func merge(arr []int, left, leftEnd, right, rightEnd int) {
    size := rightEnd-left+1
    buff := make([]int, 0, size)
    start := left
    for left <= leftEnd && right <= rightEnd {
        if arr[left] < arr[right] {
            buff = append(buff, arr[left])
            left++
        } else {
            buff = append(buff, arr[right])
            right++
        }
    }
    // 追加[left,leftEnd]
    buff = append(buff, arr[left:leftEnd+1]...)
    // 追加[right,rightEnd]
    buff = append(buff, arr[right:rightEnd+1]...)
    for i, v := range buff {
        arr[start+i] = v
    }
}
```

## 2. 快排

基本思想：每次选定一个元素排序让它回到应该待的地方，然后递归左右部分，依次下去，直到数组有序，不是稳定的算法

将数组升序排列：

填坑法，要排序的元素挖个坑，然后从后往前找个更大的元素挖掉，把坑填上，再从前往后找个更小的元素把坑挖掉，填上一个的坑，最后用最开始要排序的元素去填上一轮的坑

```go
func sortArray(nums []int) []int {
    quickSort(nums, 0, len(nums)-1)
    return nums
}

func quickSort(arr []int, l, r int) {
    if l < r {
        idx := partition(arr, l, r)
        quickSort(arr,l, idx-1)
        quickSort(arr,idx+1, r)
    }
}
func partition(arr []int, l, r int) int {
    // 在 l 处挖个坑
    p := arr[l]
    for l < r {
        // 从右往左找到比坑更小的值
        for l < r && arr[r] >= p {
            r--
        }
        // 用新找到的数填坑
        arr[l] = arr[r]
        // 从左往右找到比坑更大的值
        for l < r && arr[l] <= p {
            l++
        }
        // 用新找到的数填坑
        arr[r] = arr[l]
    }
    // 最终填坑
    arr[l] = p
    return l
}
```

## 3. 堆排

基本思想：将所有待排序元素存入一个用数组存储的完全二叉树中，该完全二叉树的特征是每个节点的值是其子树所有节点值中的最大值（或最小值），插入和删除元素都需要维持这个特征，不是稳定的排序算法

数组中的第K个最大元素：

```go
func findKthLargest(nums []int, k int) int {
    build(nums)
    return getK(nums, k)
}

func getK(nums []int, k int) int {
    for i := 0; i < k-1; i++ {
        nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]
        nums = nums[:len(nums)-1]
        adjust(nums, 0)
    }
    return nums[0]
}

// 建堆
func build(nums []int) {
    for i := len(nums)/2; i >= 0; i-- {
        adjust(nums, i)
    }
}

// 调整堆元素位置
func adjust(nums []int, i int) {
    l, r, largest := i*2+1, i*2+2, i
    if l < len(nums) && nums[l] > nums[largest] {
        largest = l 
    }
    if r < len(nums) && nums[r] > nums[largest] {
        largest = r
    }
    if largest != i {
        nums[largest], nums[i] = nums[i], nums[largest]
        adjust(nums, largest)
    }
}
```

